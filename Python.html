<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Python</title>

  <!-- Highlight.js CSS -->
  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

  <!-- Highlight.js Script -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      hljs.highlightAll();
    });
  </script>

  <!-- Eigenes Styling -->
  <style>
    body{
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:#0f172a;
      color:#e5e7eb;
      margin:0;
      padding:32px;
    }

    h1, h2{
      margin-top:24px;
    }

    /* Buttons */
    .btn{
      display:inline-block;
      padding:16px 28px;
      border-radius:12px;
      background:#2563eb;
      color:#fff;
      text-decoration:none;
      font-weight:600;
      margin-bottom:24px;
    }

    .btn-back{
      background:#475569;
    }

    /* Codeblock */
    pre{
      background:#020617;
      padding:20px;
      border-radius:12px;
      overflow-x:auto;
    }
  </style>
</head>

<body>

  <a href="index.html" class="btn btn-back">← Zurück</a>

  <h1>Python-Code</h1>
  <h2>Simulation Schleifprozess</h2>
<pre><code class="language-python">
"""
Simulation der Maschinendaten (monotone e-Funktion)

letzte Änderung: 19.02.2026
"""

import time
import datetime
import json
import numpy as np
import paho.mqtt.client as mqtt

# --------------------------------------------------------------
# MQTT Konfiguration
mq_host = "127.0.0.1"
mq_port = 1883

mq_topic_data   = "Simulation_Motor"
mq_topic_params = "Maschinensimulation/params"
mq_topic_status = "maschine/running"
mq_topic_belt   = "maschine/belt"
# --------------------------------------------------------------

# --------------------------------------------------------------
# Simulationsparameter (Defaultwerte)
params = {
    "P0": 3.5,                 # Startleistung [kW]
    "Pend": 1.0,               # Endleistung [kW]
    "tau_s": 60.0,             # Basis-Zeitkonstante [s]

    "noise_pct": 0.02,         # ±2% Rauschen

    # tau_eff Bedingungen
    "tau_jitter_pct": 0.20,        # tau_eff in [tau*(1-pct), tau*(1+pct)]
    "tau_update_interval_s": 10,   # tau_eff nur alle X Sekunden neu ziehen

    # Ausreißer: Zeitabstand zufällig [min,max] Sekunden
    "outlier_interval_min_s": 0.0,
    "outlier_interval_max_s": 10.0,

    # Ausreißer: Stärke zufällig [min,max] (Prozent als Anteil, z.B. 0.2 = 20%)
    "outlier_amp_min_pct": 0.05,
    "outlier_amp_max_pct": 0.20,

    # Schutz
    "clip_min_kw": 0.0
}
# --------------------------------------------------------------

# --------------------------------------------------------------
# State
sim_t_s = 0.0
cnt = 0
running = False

# tau_eff bleibt zwischen Updates konstant
tau_eff_current = 0.0

# Ausreißer-Planung
outlier_timer_s = 0.0
next_outlier_in_s = 0.0


# --------------------------------------------------------------
# Hilfsfunktionen
def compute_tau_eff(base_tau: float, jitter_pct: float) -> float:
    """Zieht tau_eff zufällig aus [tau*(1-pct), tau*(1+pct)]."""
    base_tau = float(base_tau)
    jitter_pct = float(jitter_pct)

    if base_tau <= 0:
        return 0.1
    if jitter_pct <= 0:
        return max(0.1, base_tau)

    low = max(0.1, base_tau * (1.0 - jitter_pct))
    high = max(low + 0.1, base_tau * (1.0 + jitter_pct))
    return float(np.random.uniform(low, high))


def schedule_next_outlier(p: dict) -> float:
    """Plant den nächsten Ausreißer in [min,max] Sekunden."""
    mn = float(p.get("outlier_interval_min_s", 0.0))
    mx = float(p.get("outlier_interval_max_s", 10.0))
    if mx < mn:
        mn, mx = mx, mn
    mn = max(0.0, mn)
    mx = max(mn, mx)
    return float(np.random.uniform(mn, mx))


def parse_running_from_payload(payload_str: str) -> bool | None:
    """
    Robust running erkennen.
    Akzeptiert:
      "1"/"0", "true"/"false", "on"/"off", "start"/"stop", "run"
      JSON: {"running": 1} oder {"running": true}
    """
    s = payload_str.strip()

    # JSON Versuch
    if s.startswith("{") and s.endswith("}"):
        try:
            obj = json.loads(s)
            if isinstance(obj, dict) and "running" in obj:
                v = obj["running"]
                if isinstance(v, bool):
                    return v
                try:
                    return bool(int(v))
                except Exception:
                    vv = str(v).strip().lower()
                    if vv in ("true", "on", "start", "run"):
                        return True
                    if vv in ("false", "off", "stop", "0"):
                        return False
        except Exception:
            pass

    # Plain string
    v = s.lower()
    if v in ("1", "true", "on", "start", "run"):
        return True
    if v in ("0", "false", "off", "stop"):
        return False

    # "1.0"/"0.0" Fallback
    try:
        return bool(int(float(v)))
    except Exception:
        return None


# --------------------------------------------------------------
# MQTT Callbacks
def on_connect(client, userdata, flags, rc):
    print("[SIM] Connected with result code", rc)
    client.subscribe(mq_topic_params)
    client.subscribe(mq_topic_status)
    client.subscribe(mq_topic_belt)
    print(f"[SIM] Subscribed to: {mq_topic_params}, {mq_topic_status}, {mq_topic_belt}")


def on_message(client, userdata, msg):
    global params, running, sim_t_s, cnt
    global tau_eff_current, outlier_timer_s, next_outlier_in_s

    topic = msg.topic
    payload = msg.payload.decode("utf-8", errors="ignore").strip()

    # 1) Parameterupdate
    if topic == mq_topic_params:
        try:
            new_params = json.loads(payload)
            print("[SIM] Parameter empfangen:", new_params)

            for k in list(params.keys()):
                if k in new_params:
                    params[k] = float(new_params[k])

            # bei Parameteränderung: neu planen (optional)
            next_outlier_in_s = schedule_next_outlier(params)

            print("[SIM] Aktive Parameter:", params)
        except Exception as e:
            print("[SIM] Parameterfehler:", e, "payload=", repr(payload))

    # 2) Maschinenstatus
    elif topic == mq_topic_status:
        parsed = parse_running_from_payload(payload)
        print(f"[SIM] Status empfangen: {repr(payload)} -> parsed={parsed}")

        if parsed is not None:
            # Übergang AUS -> EIN: Timer neu initialisieren
            if (not running) and parsed:
                outlier_timer_s = 0.0
                next_outlier_in_s = schedule_next_outlier(params)
                tau_eff_current = 0.0  # erzwingt Neu-Ziehung beim ersten Loop

            running = parsed

        print(f"[SIM] running = {running}")

    # 3) Bandwechsel
    elif topic == mq_topic_belt:
        print(f"[SIM] Band gewechselt: {repr(payload)} -> Reset")
        sim_t_s = 0.0
        cnt = 0

        # Reset von tau/outlier-state
        tau_eff_current = 0.0
        outlier_timer_s = 0.0
        next_outlier_in_s = schedule_next_outlier(params)

        print(f"[SIM] Reset: sim_t_s={sim_t_s}, cnt={cnt}, running={running}")


# --------------------------------------------------------------
# Main
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect(mq_host, mq_port, 60)
client.loop_start()

# initial outlier planning
next_outlier_in_s = schedule_next_outlier(params)

print("[SIM] Starte Simulationsschleife...")

try:
    while True:
        time.sleep(1)
        dt = 1.0
        ts = datetime.datetime.now()

        # Maschine AUS -> Nullleistung (t_s/cnt bleiben stehen)
        if not running:
            PL = {
                "t_unix": time.time(),
                "ts": str(ts),
                "t_s": sim_t_s,
                "cnt": cnt,
                "P_kW": 0.0,
                "P0": float(params["P0"]),
                "Pend": float(params["Pend"]),
                "tau_s": float(params["tau_s"]),
                "tau_eff_s": 0.0,   # MongoDB-sicher
                "running": False
            }
            client.publish(topic=mq_topic_data, payload=json.dumps(PL))
            print("[SIM] PAUSE → Nullleistung", PL)
            continue

        # Maschine EIN
        cnt += 1
        sim_t_s += dt

        P0 = float(params["P0"])
        Pend = float(params["Pend"])
        tau_base = float(params["tau_s"])

        # tau_eff nur alle X Sekunden neu ziehen
        tau_update_interval_s = int(params.get("tau_update_interval_s", 10))
        if tau_update_interval_s <= 0:
            tau_update_interval_s = 1

        if tau_eff_current <= 0.0 or (cnt % tau_update_interval_s == 0):
            tau_eff_current = compute_tau_eff(
                tau_base,
                float(params.get("tau_jitter_pct", 0.0))
            )

        tau_eff = tau_eff_current

        # Exponentielles Modell
        P_kW = Pend + (P0 - Pend) * np.exp(-sim_t_s / tau_eff)

        # Rauschen
        noise_pct = float(params.get("noise_pct", 0.02))
        P_kW *= (1.0 + np.random.uniform(-noise_pct, noise_pct))

        # Zufällige Ausreißer (Zeit + Stärke)
        outlier_timer_s += dt
        if outlier_timer_s >= next_outlier_in_s:
            amp_min = float(params.get("outlier_amp_min_pct", 0.20))
            amp_max = float(params.get("outlier_amp_max_pct", 0.80))
            if amp_max < amp_min:
                amp_min, amp_max = amp_max, amp_min

            amp = float(np.random.uniform(max(0.0, amp_min), max(0.0, amp_max)))
            sign = 1.0 if np.random.rand() < 0.5 else -1.0
            P_kW *= (1.0 + sign * amp)

            # nächsten Ausreißer planen
            outlier_timer_s = 0.0
            next_outlier_in_s = schedule_next_outlier(params)

        # Clipping (keine negativen Werte)
        clip_min_kw = float(params.get("clip_min_kw", 0.0))
        P_kW = max(clip_min_kw, float(P_kW))

        PL = {
            "t_unix": time.time(),
            "ts": str(ts),
            "t_s": sim_t_s,
            "cnt": cnt,
            "P_kW": float(P_kW),
            "P0": P0,
            "Pend": Pend,
            "tau_s": tau_base,
            "tau_eff_s": float(tau_eff),

            # optional: zur Nachvollziehbarkeit in DB
            "noise_pct": noise_pct,
            "tau_jitter_pct": float(params.get("tau_jitter_pct", 0.0)),
            "tau_update_interval_s": int(params.get("tau_update_interval_s", 10)),
            "next_outlier_in_s": float(next_outlier_in_s),
            "running": True
        }

        client.publish(topic=mq_topic_data, payload=json.dumps(PL))
        print("[SIM]", PL)

except KeyboardInterrupt:
    print("[SIM] Beende Simulation...")

finally:
    client.loop_stop()
    client.disconnect()
</code></pre>


  <h2>Abonnent "Simulation Schleifprozess" & schreiben in DB</h2>
<pre><code class="language-python">
'''

- subribed mqtt-basierte json-Daten (Maschinensimulation)
- schreibt die Daten in die MongoDB

letzte Änderung: 13.12.2025

'''
import paho.mqtt.client as mqtt
from pymongo import MongoClient
import json
# --------------------------------------------------------------
# Parameterblock
mdb_mq_host = "127.0.0.1"        # lokaler PC
mdb_db = "Motorleistung"
mdb_col = "Simulation"       # letzte IP-Adr-Nr
mq_topic = "Simulation_Motor"   # letzte IP-Adr-Nr

# --------------------------------------------------------------

cnt = 0

class mqClient():
    def __init__(self,col):
        self.col = col
        
    def on_connect(self,client, userdata, flags, rc):
        print("Connected with result code " + str(rc))
        client.subscribe("Simulation_Motor")

    def on_message(self,client, userdata, msg):
        global cnt
        cnt +=1
        print(cnt, '     ',msg.topic + " " + str(msg.payload))
        # payload enthält ein json-Objekt mit allen gesendeten Datenwerten {key1:value1, key2:value2}
        data = json.loads(msg.payload)
        print(data)
        # Schreiben in die MongoDB
        result = self.col.insert_one(data)

# __main__ ======================================================
mo_client = MongoClient(mdb_mq_host, 27017)
db = mo_client[mdb_db]
col = db[mdb_col]
# col.drop()      # Löschen der bereits erzeugten Collection (ggf. auskommentieren...)

mqC = mqClient(col)

client = mqtt.Client()
client.on_connect = mqC.on_connect
client.on_message = mqC.on_message

client.connect(mdb_mq_host, 1883, 60)

client.loop_forever()

</code></pre>


<h2>Maschinenstatus abfragen</h2>
<pre><code class="language-python">
'''

- Abfrage Maschinenzustand (Programm läuft oder läuft nicht)

letzte Änderung: 13.12.2025

'''

import paho.mqtt.client as mqtt
import time

BROKER_HOST = "localhost"
TOPIC_INPUT  = "maschine/status"    # Rohstatus vom Schalter / Node-RED
TOPIC_OUTPUT = "maschine/running"   # normalisierter Status für alle anderen

running = False

def on_message(client, userdata, msg):
    global running
    payload = msg.payload.decode().strip()
    print(f"[STATUS] Eingehend: topic={msg.topic}, payload={repr(payload)}")

    if payload in ("1", "true", "True", "ON", "on", "AN"):
        running = True
    else:
        running = False

    print(f"[STATUS] running = {running}")

    # Normalisiert als "1" oder "0" an alle anderen rausgeben
    out_payload = "1" if running else "0"
    # retained=True ist praktisch, dann bekommt jeder neue Subscriber sofort den letzten Status
    client.publish(TOPIC_OUTPUT, out_payload, retain=True)
    print(f"[STATUS] Gesendet: {TOPIC_OUTPUT} = {out_payload!r}")


client = mqtt.Client()
client.on_message = on_message

client.connect(BROKER_HOST, 1883, 60)
client.subscribe(TOPIC_INPUT)

client.loop_start()

print("Status-Normalizer läuft...")
try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    print("Beende Status-Normalizer...")
finally:
    client.loop_stop()
    client.disconnect()

</code></pre>


<h2>Berechnung Standzeit des Schleifbands</h2>
<pre><code class="language-python">
"""
Glättung und Berechnung der Standzeit 

letzte Änderung: 18.02.2026
"""

import json
import time
from statistics import mean, median
import paho.mqtt.client as mqtt

# --------------------------------------------------
# MQTT
BROKER = "127.0.0.1"
PORT = 1883

TOPIC_IN = "maschine/belt/prog"
TOPIC_OUT = "maschine/belt/prog/result"
# --------------------------------------------------

# --------------------------------------------------
# Parameter
N_CYCLES = 5              # Rolling-Fenster
MIN_CYCLE_SEC = 0         # später ggf. 30
EMA_ALPHA = 0.3           # Glättungsfaktor (0.2–0.4 sinnvoll)
# --------------------------------------------------

# --------------------------------------------------
# State
cycle_durations = []      # letzte N Zykluszeiten
last_msg_ts = None        # Timestamp der letzten Message
ema_cycle_s = None        # geglättete Zykluszeit
# --------------------------------------------------


def rolling_append(lst, value, max_len):
    lst.append(value)
    if len(lst) > max_len:
        del lst[0]


def safe_json_load(s: str):
    s = s.strip()
    if s.startswith("{") and s.endswith("}"):
        try:
            return json.loads(s)
        except Exception:
            return None
    return None


def extract_elapsed_s(payload: dict):
    if not isinstance(payload, dict):
        return None
    if "elapsed_s" in payload:
        try:
            return float(payload["elapsed_s"])
        except Exception:
            return None
    return None


def build_out(event: str, elapsed_s=None, last_cycle_s=None):
    out = {
        "ts": int(time.time() * 1000),
        "event": event,
        "cycles_used": len(cycle_durations),
    }

    if len(cycle_durations) > 0:
        avg = mean(cycle_durations)
        out["avg_cycle_s"] = round(avg, 2)
        out["avg_cycle_min"] = round(avg / 60.0, 2)

    if ema_cycle_s is not None:
        out["ema_cycle_s"] = round(ema_cycle_s, 2)
        out["ema_cycle_min"] = round(ema_cycle_s / 60.0, 2)

        if elapsed_s is not None:
            remaining = max(0.0, ema_cycle_s - elapsed_s)
            out["elapsed_s"] = round(elapsed_s, 2)
            out["remaining_s"] = round(remaining, 2)
            out["remaining_min"] = round(remaining / 60.0, 2)

    if last_cycle_s is not None:
        out["last_cycle_s"] = round(last_cycle_s, 2)

    return out


def on_message(client, userdata, msg):
    global last_msg_ts, ema_cycle_s

    now = time.time()

    # --------------------------------------------------
    # 1) Zyklus abgeschlossen → Dauer berechnen
    if last_msg_ts is not None:
        dur = now - last_msg_ts

        if dur >= MIN_CYCLE_SEC:
            rolling_append(cycle_durations, dur, N_CYCLES)

            # -------- Variante 2: Median → EMA --------
            med = median(cycle_durations)

            if ema_cycle_s is None:
                ema_cycle_s = med
            else:
                ema_cycle_s = EMA_ALPHA * med + (1 - EMA_ALPHA) * ema_cycle_s
            # ------------------------------------------

            out = build_out(event="cycle_saved", last_cycle_s=dur)
            client.publish(TOPIC_OUT, json.dumps(out), qos=0, retain=False)

    # --------------------------------------------------
    # 2) Start neuer Zyklus
    last_msg_ts = now

    # --------------------------------------------------
    # 3) Laufender Zyklus → Prognose
    try:
        raw = msg.payload.decode("utf-8", errors="ignore")
    except Exception:
        return

    payload = safe_json_load(raw)
    if isinstance(payload, dict):
        elapsed = extract_elapsed_s(payload)
        if elapsed is not None and ema_cycle_s is not None:
            out = build_out(event="prediction", elapsed_s=elapsed)
            client.publish(TOPIC_OUT, json.dumps(out), qos=0, retain=False)


def main():
    client = mqtt.Client()
    client.on_message = on_message
    client.connect(BROKER, PORT, 60)
    client.subscribe(TOPIC_IN, qos=0)

    print(f"Listening on {TOPIC_IN} → publishing to {TOPIC_OUT}")
    client.loop_forever()


if __name__ == "__main__":
    main()
</code></pre>

</body>
</html>